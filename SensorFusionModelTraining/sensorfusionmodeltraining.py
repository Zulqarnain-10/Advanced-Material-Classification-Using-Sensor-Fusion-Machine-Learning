# -*- coding: utf-8 -*-
"""SensorFusionModelTraining.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sK3GoMcKuStSg0lgH0v3OVBg7a4N7Ujt
"""

import pandas as pd
df=pd.read_csv("iyc.csv")
df1=pd.read_csv("iyv.csv")
df.info()
df1.info()
df.head()

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

# Assuming input images are 64x64 pixels with 3 color channels (RGB)
input_shape = (64, 64, 3)

# Create a Sequential model
model = Sequential()

# First Convolutional Layer
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
model.add(MaxPooling2D((2, 2)))

# Second Convolutional Layer
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))

# Flatten the output for the fully connected layers
model.add(Flatten())

# Fully Connected Layer
model.add(Dense(128, activation='relu'))

# Output layer with softmax activation for multiclass classification
model.add(Dense(4, activation='softmax'))

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Display the model summary
model.summary()

import pandas as pd
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.utils import to_categorical
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score

# Separate features (X) and labels (y) for training set
X_train = df.drop(columns=['filename'])
y_train = df['filename']

# Separate features (X) for testing set
X_test = df1.drop(columns=['filename'])

# Use LabelEncoder for encoding categorical labels
label_encoder = LabelEncoder()

# Encode the categorical labels
y_train_encoded = label_encoder.fit_transform(y_train)

# Convert encoded labels to one-hot encoding
num_classes = len(label_encoder.classes_)
y_train_one_hot = to_categorical(y_train_encoded, num_classes=num_classes)

# Normalize numerical attributes (scaling) for training set
scaler = StandardScaler()
X_train_normalized = scaler.fit_transform(X_train)

# Normalize numerical attributes (scaling) for testing set
X_test_normalized = scaler.transform(X_test)

# Define the model architecture for multi-class classification
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train_normalized.shape[1],)))
model.add(Dense(32, activation='relu'))
model.add(Dense(num_classes, activation='softmax'))  # Output layer with softmax for multi-class

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model on the training data
model.fit(X_train_normalized, y_train_one_hot, epochs=30, batch_size=16)

# Predict filenames for the test set
predictions = model.predict(X_test_normalized)

# Decode the predictions using inverse_transform
predicted_filenames_encoded = predictions.argmax(axis=1)
predicted_filenames = label_encoder.inverse_transform(predicted_filenames_encoded)
# Display the predicted filenames

def categorize_class(filename):
    if 'glass_cup' in filename.lower():
        return 'Glass Cup'
    elif 'glass_bottle' in filename.lower():
        return 'Glass Bottle'
    elif 'metal_spring' in filename.lower():
        return 'Metal Spring'
    elif 'plastic_bottle' in filename.lower():
        return 'Plastic Bottle'
    elif 'plastic_cup' in filename.lower():
        return 'Plastic Cup'
    elif 'metal_nut' in filename.lower():
        return 'Metal Nut'
    else:
        return 'Class Miscellaneous'

# Apply the function to categorize classes for each filename in the DataFrame
result_df['True Class'] = result_df['True Filename'].apply(lambda x: categorize_class(x))
result_df['Predicted Class'] = result_df['Predicted Filename'].apply(lambda x: categorize_class(x))
result_df = result_df.rename(columns={'_1': 'True Labels'})
# Display the DataFrame with the updated column name
accuracy = accuracy_score(result_df['True Class'], result_df['Predicted Class'])

# Display the DataFrame with the updated column name and accuracy
print(result_df)
print(f"\nAccuracy: {accuracy}")
classification_rep = classification_report(result_df['True Class'], result_df['Predicted Class'])
print("\nClassification Report:")
print(classification_rep)
