# -*- coding: utf-8 -*-
"""MaterialSortSignal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pNFv-1ALJN5NFCqiDowBNQNZ6jhtzTcO
"""

import subprocess
from time import sleep
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import RPi.GPIO as GPIO


# Load the trained model
model = load_model('path/to/your/model.h5')

# Set up GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Define the GPIO pins for each class
glass_pin = 17
metal_pin = 27
misc_pin = 22
plastic_pin = 10

# Initialize GPIO pins
GPIO.setup(glass_pin, GPIO.OUT)
GPIO.setup(metal_pin, GPIO.OUT)
GPIO.setup(misc_pin, GPIO.OUT)
GPIO.setup(plastic_pin, GPIO.OUT)

def capture_image():
    image_path = '/home/pi/captured_image.jpg'  # Define the path to save the captured image
    # Use libcamera-still command to capture an image
    subprocess.run(['libcamera-still', '-o', image_path])
    print(f"Image captured and saved to {image_path}")
    return image_path

def classify_image(image_path):
    # Load the image using Keras preprocessing
    img = image.load_img(image_path, target_size=(224, 224))  # Adjust target size as per your model
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
    img_array /= 255.0  # Normalize the image data to 0-1 range

    # Make prediction
    predictions = model.predict(img_array)
    predicted_class = np.argmax(predictions, axis=1)[0]  # Get the index of max value

    # Map the model's predicted index to specific class numbers
    class_labels = {0: 'glass', 1: 'metal', 2: 'miscellaneous', 3: 'plastic'}
    predicted_label = class_labels[predicted_class]

    print(f"Predicted class: {predicted_label} ({predicted_class})")

    # Set the corresponding GPIO pin high based on the predicted class
    if predicted_class == 0:
        GPIO.output(glass_pin, GPIO.HIGH)
    elif predicted_class == 1:
        GPIO.output(metal_pin, GPIO.HIGH)
    elif predicted_class == 2:
        GPIO.output(misc_pin, GPIO.HIGH)
    elif predicted_class == 3:
        GPIO.output(plastic_pin, GPIO.HIGH)

    return predicted_class

# Main execution loop
while True:
    # Reset all GPIO pins to low
    GPIO.output(glass_pin, GPIO.LOW)
    GPIO.output(metal_pin, GPIO.LOW)
    GPIO.output(misc_pin, GPIO.LOW)
    GPIO.output(plastic_pin, GPIO.LOW)

    image_path = capture_image()  # Capture an image
    classification_result = classify_image(image_path)  # Classify the image
    print(f"Classification result: {classification_result}")
    sleep(5)  # Wait for 5 seconds before capturing the next image

# Clean up GPIO at the end of the program
GPIO.cleanup()
